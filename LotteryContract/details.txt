
LotteryContract
    > Prize Pool
    > List of people who enter it (each person sends ether to the pool)
        (Each person who sends eth becomes a player)
    > A third party launches the function to choose a winner
    > The contract will pick a winner and award the entire prize pool to that winner
    > Once someone wins, reset contract state:
        -> Empty players array

    structure:
        variables
            manager: Address
            players[]: Array<Address>

        functions:
            enter
            pickWinner
            getPlayers


Basic Types:
    string
    bool
    int (+ve or -ve)
    uint (unsigned)
    fixed(decimal +ve/-ve), ufixed(decimal, unsigned)
    address

    notes:
        only int => int32
        int8 range: -127, 128
        uint8 range: 0, 255


Function Types:
    public: Anyone
    private: self callable only
    internal: self & derivative callable only
    view: returns data but DOES NOT write contract data
    constant: returns data but DOES NOT write contract data (same as view)
    pure: Doesn't even read / write contract data
    payable: Accepts ether sent via function call


msg global variable
    data: (on transaction)
    gas: (available gas)
    sender: (account who send tx/call)
    value: (contains ether that has been sent in)


Solidity Reference Types:
    1. Arrays [All Values same type]
        Fixed length: type[length]
        dynamic length: type[]

        Note: (Autogenerated caller func for array variable) does not give back the array, instead
        it expects an index and returns the value at that index.

    2. Mappings (KeyValue-Pair) [All Keys should be same type, all values should be same type]
        (Used to represent many things)
        mapping(string => string)

    3. Struct -> Similar to mapping but values can be of different types
        (Used to represent a singular thing)
        struct Car{
            string make;
            string model;
            uint value;
        }

Gotchas:
    1. Solidity Supports Nested Dynamic arrays but the Web3 ABI does not
    2. Solidity considers some types like Strings as dynamic arrays and due to fact (1) we cannot have 
        arrays of strings (can use it in the contract but cant bring it to Web2)

Get the balance of current contract: address(this).balance

Function Modifiers:
    modifier <Name>() {
        ...logic
        _;
    }